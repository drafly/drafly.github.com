---
layout: post
title: "机器学习-自步学习"
description: ""
category: "机器学习"
tags: []
---
{% include JB/setup %}

## 1. 自步学习

现有机器学习方法都需要解决非凸优化问题，例如学习感知机或深度置信网，传统的优化方法在避免非凸优化问题陷入较差局部解时，往往采用多次随机初始化方式训练模型，然后选择其中效果最好的初始化结果构建模型。然而这种方法过于adhoc，而且计算代价过高。课程学习和自步学习最开始就是作为解决非凸优化问题而提出的。Bengio教授在2009年ICML上提出课程学习，而自步学习则是在课程学习的基础上，由Koller教授团队在2010年NIPS上将该思想建立为具有理论基础的数学表达形式。课程学习和自步学习的核心思想是通过模拟人的认知机理，首先学习简单的、普适性的知识结构，然后逐渐增加难度，过渡到学习更复杂、更专业化的知识$$^1$$。

![自步学习](/img/ml/spl/spl.jpg)

课程学习是对于特定问题而言，根据先验知识或启示赋予样本不同的学习特性或学习先后顺序。例如：大学课程中一般会设定先学习线性代数，然后再学习高等数学，这其中是根据先验知识对知识学习顺序的指定（instructor driven）；在自然语言处理中，如果我们人为指定数据输入顺序按照短句——长句、简单句——复杂句的方式也可视为是利用课程学习训练模型的一种体现。相对于课程学习，自步学习则是对于已学习获得的模型而言，赋予样本不同的学习难易程度（easiness or confidance）。例如：我们完成9年义务教育准备高考复习时，会做一本习题书《5年高考-3年模拟》。假设，我们做第一遍试题时仅会做简单的加减乘除，复杂的微积分都做错。随着不断的重复做模拟试题以及比对正确答案，我们可以逐渐答对复杂的高等数学问题。这个过程可以认为是自学习过程（student-driven），而线性代数在该过程被认为是简单样本，相对地，高等数学则被认为是复杂样本，每次刷题的过程对应为已学习获得的模型。

![课程学习解释](/img/ml/spl/curriculum.jpg)
![自步学习解释](/img/ml/spl/selfpaced.jpg)

在机器学习研究中，我们自然也可以将学习对象(数据、特征、概念等)按其对学习目标的难易程度，从易到难开展学习，以这种方式让机器完成复杂的学习与推理任务。自步学习研究的关键是假设样本的选择并不是随机的，或是在一次迭代中全部纳入训练过程中，而是通过一种由简到难的有意义的方式进行选择的。自步学习中从简单到复杂的样本选择过程是指，简单样本可以理解为具有较小的损失（smaller loss）或较大似然函数值（likelihood）的样本，复杂的样本具有较大损失（larger loss）的样本。

## 2. 相关应用

近年来，自步学习理论已经被应用到很多任务中，并取得了state-of-the-art的结果，例如，Zhao et al.$$^2$$提出SPMF算法对非凸矩阵分解问题、Jiang et al.$$^3$$提出SpaR方法用于解决多模态多媒体事件检测问题、Zhang et al.$$^4$$提出SP-MIL模型实现显著性检测；Jiang et al.$$^5$$提出SPLD方法并应用于视频动作识别中；Deva et al.$$^6$$将自步学习应用于物体跟踪；Han et al. $$^7$$提出SPMoR模型将自步学习应用于混合模型的健壮估计中。SPL优势在于可以针对特定任务设计不同的自步正则项，用于表征和定义“简单”样本。例如，最基本的SPL正则项为标准的LASSO（norm），用于从所有样本中选择稀疏的、有竞争力的样本，即样本具有很小的训练误差、高似然值或者高置信度；SPLD和SP-MIL分别引用和范数作为自步学习正则项，这两种正则项都属于Group LASSO$$^{8,9}$$，和不同子集间选择变量，促使保留稀疏的子集，因此在自步学习中，二者都起到鼓励在多个子集中选择样本的作用，并避免子集间的稀疏性.

从健壮估计角度来看，自步学习理论本质上是一种健壮学习机制，自步学习定义的简单样本是指在学习过程的每次迭代中被选择的样本不会存在预测误差或代价超过一定阈值的样本，我们也称之为“置信度高”的样本。对于噪声或者异常值而言，它们必然会增加学习过程的难度，使得估计误差较大，进而可以被看做是“置信度低”的样本，也就不会被选入自步学习的学习过程中。SPMoR就是利用自步学习的特性，提出一种基于Exclusive LASSO的新自步学习正则项，在鼓励混合模型各成分内样本的竞争，而且避免成分间的竞争，使得混合模型在每个成分中都选择一定数量的样本，且每个成分中只倾向于选择置信度高的样本，遮蔽噪声数据的同时，避免自步学习在每次迭代过程中在各成分间选择样本数量的不均衡。

## 3. SPL

接下来主要介绍Koller教授$$^{10}$$的自步学习（SPL）文章，下篇博文会重点介绍Lu Jiang的SPLD文章。

假设训练集$$D={(x_i, y_i), \ldots, (x_i, y_i)}$$存在$$n$$个样本，每个样本$$x_i$$代表一个样本，$$y_i$$表示对应样本的类别标签，$$w$$表示对应模型的待优化参数，参数$$w$$的正则项记为$$r(w)$$，模型的损失函数记为$$f(x_i, y_i, w)$$。传统机器学习方法的目标函数记为：

$$w_{t+1} = argmin(r(w) + \sum_{i=1}^n f(x_i, y_i, w)).$$

自步学习核心思想是在每次迭代过程中倾向于从所有样本中选择具有很小的训练误差、高似然值的样本，然后更新模型参数。每次迭代选择样本的数量由权重参数确定，该参数通过逐次衰减实现引入更多的样本，当所有样本已被选择或者代价函数无法再降低则停止迭代。

<!-- 需要指出的是，自步学习中的“简单和复杂”并不是针对单一样本，我们无法指定某一样本是“简单”样本，而另一样本是“复杂”样本，SPL对样本难易程度的定义是针对的所有样本的某一子集，因为所有样本中至少会有一定数量（大于1）样本估计误差很小。 -->

<!-- Note that, in self-paced learning, the characterization of what is “easy” applies not to individual samples, but to sets of samples; a set of samples is easy if it admits a good fit in the model space. -->


因此，自步学习在传统机器学习目标函数中引入二分变量（binary variable）$$v_i$$，用于表征每个样本是否被选择，或是否为简单样本，例如：似然值高的、远离分类边界的点。因此，仅有$$v_i=1$$的样本被纳入目标函数计算中，其目标函数可以改为：

$$(w_{t+1}, v_{t+1}) = argmin(r(w) + \sum_{i=1}^n v_i f(x_i, y_i, w) - \frac{1}{K} \sum_{i=1}^n v_i).$$

其中，$$K$$为自步学习参数，用于决定哪些样本被选入自步学习中。如果$$K$$值较大，目标函数优化过程则倾向于选择损失$$f(\cdot)$$很小的样本。随着迭代次数的增加，我们逐渐减小$$K$$的值，当$$K$$值趋近于0时，越来越多的样本被选择。此时，自步学习训练过程则退化为传统机器学习训练过程。因此，自步学习的过程可以理解为从开始少量“简单”样本开始，逐渐引入更多样本，直至所有样本被选择进入模型。

最基本的SPL的优化过程很简单。当$$f(x_i, y_i, w) \leq 1/K$$时，$$v_i = 1$$，当$$f(x_i, y_i, w) > 1/K$$时，$$v_i = 0$$。特别地，当$$f(\cdot)$$和$$r(\cdot)$$均为凸函数时，上述自步学习的优化问题可以转化为双凸优化问题（biconvex optimization problem）。双凸优化问题是指对于待优化参数集合$$z$$而言，参数集合可以被划分为互斥的两个集合$$z_1$$和$$z_2$$。如果任意一个参数集合$$z_i$$固定一组参数值时，另一组参数的优化问题可以看做是凸优化问题，那么该问题可以视为双凸优化问题。例如，在上述表达式中存在两组参数$$w$$和$$v$$，我们可以交替固定$$w$$求得$$v$$的最优解，然后固定$$v$$求$$w$$的最优解，该优化方法可以称为alternative convex search (ACS)方法，可以保证求得函数的局部最优解。

## 4. 自步学习和其他方法的区别

机器学习方法中也存在相关方法用于选择样本，例如：主动学习（active learning）和协同训练（co-training）。自步学习与二者的区别在于自步学习中所有样本的标签是完全存在的，在每次迭代过程中，我们可以通过计算预测值和标签的差别来选择置信度高的样本。而主动学习和协同训练往往应用于半监督学习框架，其中主动学习倾向于选择当前模型下确定性或置信度低的样本，而协同训练则是从无标签数据中选择分类器认为置信度可能高的样本，选择的样本并没有标签，无法断定估计结果是否准确。相比之下，自步学习则是选择预测值与真实值接近的、即分类器可以分辨的置信度真的高的样本。

## 5. 参考文献
[1] [Deyu Meng老师主页](http://gr.xjtu.edu.cn/web/dymeng/6;jsessionid=AE8EDF6AD1FBE4978510A0B02D2DED81).

[2] Q. Zhao, D. Meng, L. Jiang, Q. Xie, Z. Xu, and A.G. Hauptmann. Self-Paced Learning for Matrix Factorization. AAAI, 2015, 3196–3202.

[3] L. Jiang, D. Meng, T. Mitamura, and A.G. Hauptmann. Easy samples first: Self-paced reranking for zero-example multimedia search. MM, 2014, 547–556.

[4] D. Zhang, D. Meng, and J. Han. Co-saliency detection via a self-paced multiple-instance learning framework. IEEE TPAMI, 2016, online published.

[5] L. Jiang, D. Meng, S.I. Yu, Z. Lan, S. Shan, and A.G. Hauptmann. Self-paced learning with diversity. NIPS, 2014, 2078–2086.

[6] J.S. Supancic and D. Ramanan. Self-paced learning for long-term tracking. CVPR, 2013, 2379–2386.

[7] L. Han, D. Zhang, D. Huang, X. Chang, J. Ren. IJCAI, 2017, accepted.

[8] [Lu Jiang SPLD主页](http://www.cs.cmu.edu/~lujiang/spld/).

[9] [Dingwen Zhang主页](https://zdw-nwpu.github.io/dingwenz.github.com/).

[10] Kumar M P, Packer B, Koller D. Self-paced learning for latent variable models. NIPS, 2010, 1189-1197.